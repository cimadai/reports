# buildersconまとめ

## 2016/12/03 10:00 〜

### 10:10 - 11:20 @A: OSS は Windows で動いてこそ楽しい Go言語への誘い
#### mattn さん
##### 資料) https://mattn.github.io/builderscon2016/#0

- Windowsは開発に向いているのか？
    - IDEはたくさんあって開発しやすそうな感じではあるけど、問題は多い。
    - 文字コードとか特異なAPIとか、他のOSと違うところがたくさん。
    - fork / exec / signal / unix ドメインソケットがない etc...

- なんとか置き換える方法はある。
    - unixドメインソケット
        - -> TCP/IP ソケット
    - signal
        - -> Windowsメッセージ
    - fork
        - -> スレッドでなんちゃってfork
    - ソケットディスクリプタの違い
        - Windowsはソケットはハンドルなので、そのままread/writedできない。
        - read/writeやるにはなんとか変換しないといけない。
        - epollも自作でゴリゴリやらないといけない。
    - 動かないから動くから楽しいしやる楽しさがある。
        - Windows移植は縛りプレイｗ

- そんななかでGo言語がさっそうと登場。
    - Goは内部エンコーディングはutf-8
    - ソケットも初期化しなくていい(WSA-*)
    - 洗練された標準パッケージ
    - Windowsにとっても優しい
    - deferはWindowsに優しい。
        - ハンドルを持ちっぱなしになることがない。
    - filepathはWindowsに優しい。
        - ドライブ名とか、スラッシュセパレータとか、toSlash/fromSlash
    - マルチバイト問題
        - TOMB問題が起きない。
    - netパッケージはWindowsに優しい
        - ソケットがread/writeできる。
        - Windows特有のコードやifdefが必要ない。
        - ソケットはI/O Completion Portで処理されるので完全非同期

- ただし、気をつけないと文字化けすることも。
    - C:\>dir | my-goapp
    - dirの出力はANSIエンコーディングなので、その[]byteをｓstringにすると化ける。
    - とにかく取り巻く環境すべてをUTF-8で統一すべし。


- 標準パッケージで解決出来ない問題。
    - 端末制御。
    - 出力がパイプか端末か知りたい。
        - go-isatty でできる。
    - エスケープシーケンスで色を出したい。
        - go-colorable でできる。
    - ログをローテーションしたい
        - go-sizedwriter でできる。
    - Access/MDBを扱いたい。(そんなことはない)
        - go-adodb でできる。
        - CSVも扱えるしpostgreSQLだって大丈夫。
    - sixel扱いたい
        - VT2xx-VT2xxに搭載されていた、端末に画像を表示する機能
        - go-sixel

- MotionJPGを使えば動画も出せるか？
    - gstreamerからmjpegでエンコードして、動画を配信
    - Goで書いたプログラムで端末に表示

- Vimstreamer
    - gstreamer + goによるブリッジ + vim8
    - VimはXPMに色がつく
    - 大分減色するもののVimで動画再生！すごい！

- デスクトップマスコット
    - go-gtkを使うとWindowsのネイティブAPIを叩いていろいろできる。
 
- vim-jpはコントリビュートしやすい。


### 11:20 - 11:50 @B: 動け！Golang 〜圧倒的IoTツール開発へようこそ〜
#### kazuph さん (本間和弘) Photosynth 取締役CTO Akerunの会社
##### 資料) https://speakerdeck.com/kazuph/dong-ke-golang-ya-dao-de-iotturukai-fa-heyoukoso

- IoTの中のoTの部分にフォーカスした話。
    - メカ、エレキ、ファームウェア、工場、ロジスティクス、調達

- 工場で動くIoTツール
    - IoTと工場は相性がいい。

- 工程管理
    - ファームウェアのIDのユニークに発行
    - 作業の工程の成否のトラッキング
    - 基盤や筐体にシール発行
- 検査系
    - 基盤、部品、組み立て毎の検査

- IDの管理をしないといけない。
- マイコンに書く時の書き込み作業
- 筐体検査も手作業は無理なので何か考えないといけない。
    - →IoTで工場も自動化する

- 工場IoTツールでの自動化
    - Raspberry Pi + golang + shell
    - iPod + iOS app(Swift)
    - クラウドはAWS + Rails, それと工場内の端末がWebAPIでつなぐ。
    - さらにそれらの端末とIoTデバイスをBLEでつなぐ。
    - 検査で問題があればSlackへ通知。
    - ツールハッカソンの日！という感じで突貫で１日でつくった。
    - 1ファイルでsinatraで256行とshell43行だけ。

- ツールのつくり
    - Webサーバー部分はnet/http
    - BLE操作はpaypal/gatt
    - クレデンシャル情報は.envからロードしてバイナリに含める。
    - 工場でのぞかれてももとのソースが見れないように1バイナリ+複数のシェルにした。
        - アセットもすべてバイナリに含める。
    - サーバーとしてラズパイをつかって、systemdで常駐化。 
    - 常駐化させて常に動かす的なアプリなので、結局はWebサーバー化した。
    - RubyならSinatra, Golangならnet/http
    - ビルドなど面倒なところはshellに投げる。

- BLEのAPI
    - Obj-C, Swirft, Golangなど、基本的に普通にやるとコールバック地獄
    - でもGolangのごルーチンとチャネルでなんちゃってでシリアルで書ける。
    - しかしRxXXを使わないと死ぬ

## 11:50 - 12:05 @B: Automatic Smile Camera を作った話 - 親バカハックノススメ
#### yosuke-furukawa さん リクルートテクノロジーズ
##### 資料) https://speakerdeck.com/yosuke_furukawa/automatic-smile-camera-at-builderscon

- Node学園祭のオーガナイザーなどNodeJS界隈の人。

- やったこと
    - Intel Edison に webcam をつけて表情解析
    - ※これはラズパイでもなんでもいい。

- まずOpenCVで表情認識。
    - detect faceで顔領域を抽出。
    - chained classifierでさらに笑顔を抽出。
        - 顔だと認識された区画のカナから更に分類する。
        - 半分よりも下に半月型の領域がある。となれば笑顔と認識できる。

- OpenCVで笑顔認識されたものをGoogle Cloud Vision APIでより正確に認識

- 全体の流れ
    - Capture Picture by IoT Camera -> OpenCV detects smile -> Google Cloud Vision API -> Send to Slack
    - なぜOpenCVを挟んだ？
    - Google Cloud Vision APIの無料枠に収めるため。

- 今ある問題
    - Intel edisonが遅い。もっとCPUパワーが必要。
    - OpenCVは傾いた顔が識別できない。
    - Google Cloud Vision APIはそこまで子供の表情を分析できない。

*Hack for your babies*

### 13:10 - 14:10 @A: 人工知能によってプログラムを有機化する
#### 三宅陽一郎さん youishiro.miyake
##### 資料1) http://www.slideshare.net/youichiromiyake/builderscon-2016-69784983
##### 資料2) http://www.slideshare.net/youichiromiyake/builderscon-2016-69785059

- AIの移り変わり
    - 以前は Scripted AI(あらかじめ決めたことだけをやる。操り人形型)
        - ゲームデザイナーが作ってた。
    - 最近は自立型AI (AI自体に考えさせる)
        - ゲームデザイナーが考えるアルゴリズムをAIに持たせる。

- AIを作るということ
- データ(=知識)とアルゴリズム(=思考)がすなわち"知能"。
- 最小の人工知能 = シンプルな知識と思考のペア
    - 一つの問題につき一つの最小ペアを持つのが基本。
    - これを階層的にすると階層型アーキテクチャになる。
    - 人工知能を複雑にする場合はこのアプローチで階層を増やしていく。
- ステートマシンはもっとも簡単な意思決定アルゴリズム
    - 巡回型兵士はステートマシンでつくられている。
    - 攻撃、待機、パトロールetc...

- 思考を選ぶ思考(メタ思考アーキテクチャ)
- ルールベース意思決定(推論エンジン)
- ユーティリティベースという意思決定
- 単純思考を並列に並べる。レイヤードアーキテクチャ。
- サブサンプションアーキテクチャ
    - 上の階層が下のアーキテクチャをいつでも停止できるようなもの。
    - 最近のロボットはすべてサブサンプションアーキテクチャ。

- 人工知能へ。

- エージェントアーキテクチャ
    - 世界、キャラクター、知識、意思決定、運動生成、発話
    - インフォメーションフロー
        - データが知識モジュールを駆動させる。
        - 人工知能が眠っている時は内部インフォメーションフローが周り、情報をクリーンナップする。
            - 人間の睡眠時の夢の役割みたいな。
    - 未知のものをどう解釈するか。→センサーが重要。
        - 囲碁とか将棋はデータ型が自明なので世界と知識がダイレクトにつながる。
        - しかしロボットはセンサーが重要。
    
- 知識構造
    - 知識表現モデル
    - ものを動かせるか？(アフォーダンス情報)とか
    - 薬草は大量を回復できるとか
        - KR: Knowledge Representation
    - オブジェクト表現
        - ドアの知識表現
            - ドアを引くと動く
        - レバーの知識表現
            - レバーを引くと扉が開く
        - 車の知識表現
            - 車は前に進む
    - アフォーダンス
    - 知識表現を準備しないゲームが多いが、知識表現をちゃんと準備すると思考はすくなくて済む。
    - AI開発の半分以上の作業は知識表現を如何につくるか、になる。
    - 思考が全てだ、と考えているとものすごく破綻しやすい。
    
- WayPoints大事
    - ナビゲーション・メッシュモデル
    - ダイクストラ法でのパス検索
        - 中心から同心円上に広げていく。
        - ユーリスティック距離は普通ユークリッド距離を取る。
        - A*法
    
    - 敵が立つ位置の決定システム(TPS)
        - 動的にランダムに生成。その後、不必要な場所を消していく。
        - 知識表現がしっかりしていれば、場所をgenerationしてfilteringする。
    - ゲーム全体の知能化
        - ゲームにもよるが、結構ぐちゃぐちゃになることは多い。
        - プレステくらいになるとうん十万行になる。
        - かつてのゲームはどこが描画でどこがスコアリングで、という区別がなかった。
        - しかし最近は３つのAIに分離している
        - キャラクターAI
            - 自律的な判断、仲間同士の強調、ときにチームAI
        - メタAI
            - エージェントを動的に配置
            - レベル状況を監視
            - キャラクターの指示
            - ゲームの流れを作る
        - ナビゲーションAI
            - メタAI、キャラクターAIのためにレベルの認識などをやる。
        
- かつてはゲーム出荷時にゲームの難易度は固定されていたが、最近では難易度調整が
  AI化されているのでユーザーの熟練度によって自動的に変わる。

- 意思決定モデル
    - 7つのアルゴリズムがある。
        - リアクティブ
            - ルール
            - ステート
            - ビヘイビア
        - 非リアクティブ
            - ゴール
            - タスク
            - ユーティリティ
            - シミュレーション
    
- まとめ
    - 静的な思考から動的に生成される思考へ。
    - ソフトウェアを人工知能化する == 人工知能を作る。
    - Xbox360とかPS3くらいまでは、操り人形型(Scripted AI)AI
    - 今（PS4以降）は思考をすべてその場で生成する。
    - イベントとかは自動生成に向かっている。
        - 動物、兵士、村民などいる時に、ユーザーが退屈しているかも、と判断したら
          ゾウと村民が戦ったりするイベントが生まれたり。
    - ストーリージェネレーションまでAIが担保できるようになれば最高。
        - ストーリーのパーソナライズド。
    - 学習について。
        - ゲームではそこまで使うことができない。
        - 学習は失敗することも含めて学習なので、コントロールしきれなくなるのであまりやることはない。
    - QAを人工知能に置き換える、ということをしている。
        - ベテランプレイヤーっぽいAIを作ってやる。

### 14:20 - 15:20 @A:  Highly available and scalable Kubernetes on AWS
#### mumoshuさん kube-awsのメンテナー
##### 資料) http://qiita.com/mumoshu/items/922a36dec039e8d230f9

- 似ているもの
    - Docker Swarm
    - Hashicorm Nomad
    - Kontena
    - AWS ECS
    - など

- kuberunetesの特徴
    - Planet Scale
        - Googleの技術を利用しているのですごい
        - 実際にリリースする前に、2000台のサーバーで6000個のインスタンスでテストとしている
    
    - Never Outgrow
        - Outgrowとは成長して服が着れなくなるみたいなこと。
        - 開発環境と本番環境で同じように扱えて、サイジングの違いで困ることはない。
    
    - アプリを作りたいのであって運用したいわけではない、というのがkubernatesの良さ。
    - golangで出来ている。
    - いろいろあるが、minikubeで自分のPCでも動かせる。

### 15:30 - 16:00 @A: そろそろプログラマーもFPGAを触ってみよう！
#### kazunori_279さん
##### 資料) http://qiita.com/kazunori279/items/a9e97a4463cab7dda8b9

- 各社FPGAに注力してきている。
    - AWSがFPGAインスタンスを開始。
    - インテルが去年Alteraを買収。
    - MSも全面的に採用。
        - Bingの検索はFPGAでアクセラレートして２倍高速化。
    - IBMもFPGAホスティング開始。

- 用途
    - 特徴量の抽出で使ったり。
    - 翻訳サービスも超高速化。
    - 債券のリスク分析を8時間が4分に。
    - IBMのNetezzaやOracleのExsaを使うと早い。これはFPGAが組み込まれているから早い。
    - High Frequency Trading (HFT)マイクロ秒単位で売買
    - ニューラルネットもFPGA
        - 東工大中原先生がやった事例。電力消費も２桁くらい違う。

- ムーアの法則は終わった。
    - →ハードウェアでアクセラレートするしかない。
- CPU
    - ノイマン型。バスなどボトルネックが多い。
    - キャッシュがシリコンダイのほとんどを埋める。
    - コンテキストスイッチを切り替えるのが大変。
- GPU
    - 浮動小数点演算をこなすには抜群だが、高いし電気代かかる。
- ASIC
    - 特定処理に対しては超絶早い。電力消費量も少ない。
    - しかし作るのがめちゃくちゃ高い。
- FPGA
    - 回路設計を自由にできて書き換え柔軟。GPUとASICの間の子。
    - Fluentdをちょっとハード実装してみたいな、とおもったらFPGAで出来る。
    - デジタル回路を自分で設計できるので大人の電子回路。
    - 安いやつだと5000円くらい。
    - SRAMですべての回路情報を持っている。
    - 特徴量計算機を作って並列に並べることで超高速化。
    - 1000個の特徴量を抽出するならば、1000個の計算機を配置すれば数クロックで終わる。
    - 東大佐野先生 パイプライン・ストリーム処理が得意
    - ハードウェアアルゴリズムなら、ソートもあみだくじみたいなソートアルゴリズムをつくれる。
        - O(log n)でできる。
    - メッセージパックのエンコーディングをFPGAで書いてあげてメッセージにして、
    - あとはハードウェアでTCP/IPを実現しているものがあるので、それをつなげれば通信もできる。

- FPGAで向かない用途
    - 大きなデータにランダムアクセスするもの。
        - 内部のSRAMに収まる演算だと激速
        - 収まらないとDRAMアクセスして遅い
    - そもそも並列化の難しい処理
        - クロック遅いので逐次処理はCPUにかなわない
    - ソフトやGPUでさっさと用が済む用途
        - FPGA開発のコストと天秤
    - いずれASICに乗っ取られる用途
        - 年単位で使用がかわらないようなもの。

- 高位合成だ！
    - High Level synthesis
    - ハードウェア言語で作るのは結構辛い。
    - みよしさんのSynthesijer (Java/Scala)
    - PyCoRAM Python

- TensorFlow -> OpenCL -> HDL
    - 中原先生のデモ。

- Xilinx PYNQ: という2万円くらいのハード。
    - Pythonで記述する。
    - 面白そう。

### 16:00 - 16:15 @B: Docker swarm mode などで作る PaaS モドキとその悲しみ
#### ssig33さん: 小池陸さん

- 結論から
    - いますぐDockerbaseでHA環境作らないといけない人
        - kuberunetesを使いましょう。
    - ベンチャー企業でインフラのコストを下げたい人
        - おとなしくherokuつかっとけ。
    - kubernetesに比べてdocker swarmが優れている点
        - 設定が簡単。
        - Docker swarm modeは超シンプル
        - マスターノードはマルチマスターができる。
    - 優れていない点
        - たくさん...

- 問題
    - docker swarm modeのノードディスカバリとか全然動いてない。
        - 前段にロードバランサを置けばなんとかなる。
    - ステータスも Unknownになる。
        - 死活監視をしましょう。
    - 単発実行のタスクデプロイができない。
    - ジョブスケジューラもない。
    - MySQLなどファイル永続化の場所が難しい。
        - もうどうしようもない。
        - パフォーマンスが必要ないならglusterfsとかつかえばよさそう。
    - 複数のサービスをひとまとめにして管理する機能がない。(pod的な)
    - ログ管理がない。
        - docker service logというのを作っている所。
        - ssig33はlogspoutをつかっている。
    - ドキュメントがない。
        - githubのissueとか読めば結構いい。
    - 企業内のテスト用インフラくらいならなんとかなる。

### 16:15 - 16:30 @B: 世の中の困り事はだいたいGoのコード自動生成で解決する
#### @makopy  or  mackee_wさん: カヤック

- Goは 何も準備しないとコピペが増えるので、interfaceをガンガン使うべし。
- それでも上手くいかないときはコード生成。
- 他のエコシステムと接続できる
    - HTTPのquery stringやformをgoのstructに変換できる。
    - APIだったらそもそも定義があるんだろうし、IDLで決める。
    - 一般的にはSwaggerとかProtocol.BuffersやJson scheme
    - interfaceパズルで組み立てていく。
- go-sqllaを使うと型チェックがしっかりできるので安全。
    - go-bindataを利用してテンプレートの埋め込みしている。
    - genbaseという型名とかをとれるユーティリティも使ってる。
- コードを生成する方法はtext/templateを使うのがかなり良さげ。


### 16:40 - 17:40 @A: Bluetooth キーボードの作りかた
#### cho45さん
##### 資料) https://lowreal.net/2016/12/03/1

- 回路
    - BLE接続インターフェース
        - BLE Nano
        - Nordic nRF51822
        - Arm cor tex 
        - mbed 対応 (C++のモダンなAPIでプログラミングできる)
        - ライター付きで$32.90
    - キースイッチのハンドリング
        - I2C GPIO 拡張 MCP23017
        - BLE nanoだとIOが足りない
        - INTpinあり。有り込みピン
        - これをつかってMCUに割り込みを発生させることができる。
        - I2C: SDA/SCLという信号線２本。低速だが使い勝手が良い。
    - 左右をつなぐコネクタ
        - 8P8C RJ45/LANコネクタにした。
        - 少し大きいが、LANコネクタは入手性が良いのでそれを採用。
        - 左右で繋ぐ必要がある戦はVDD/GND/SCL/SDL/INTの5接点をつなげる必要がある。
    - キースイッチ
        - gateron 左右合わせても $30くらい。
    
- 回路図
    - KiCAD
        - OSS
        - eeschema 回路図作成
        - pcbnew プリント基板作成
        - 公式のチュートリアルがとても良く出来ている。
    - Eagle
        - 商用。
        - 100mm x 80mm だったら非商用のフリープランがある。
    - freerouting (OSS)
        - KiCAD -> freerouting -> KiCAD
        
- ファームウェア結構つらみがある。
    

### 次回
- 2017, Aug 2-5
- http://2017.tokyo.builderscon.io/
- Sponsors Wanted!
